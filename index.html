<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8" />
    <title>Timeline of events</title>
    <link rel="stylesheet" href="app/styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;600;700;800;900&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Fira+Sans:wght@700;800&display=swap"
      rel="stylesheet"
    />
  </head>  

  <body>
    <header>
      <h1>A Timeline For Horizon</h1>
      <p class="subtitle">
        Explore the main events from Aloy's universe in an interactive way.
      </p>
      <br />
      <p class="quote">
        <i
          >"The strength to stand alone is the strength to make a stand." -
          Rost</i
        >
      </p>
    </header>

    <!-- Year Navigation Timeline -->
    <div class="year-navigation-container">
      <!-- Historical Periods Timeline -->
      <div class="historical-periods">
        <h3 class="timeline-section-title">Historical Period</h3>
        <div class="periods-container">
          <div class="periods-line"></div>
          <div class="periods-track" id="periodsTrack">
            <!-- Period markers will be inserted via JavaScript -->
          </div>
        </div>
      </div>

      <!-- Years bar -->
      <div class="year-timeline">
        <h3 class="timeline-section-title">Years</h3>
        <div class="year-timeline-line"></div>
        <div class="year-markers" id="yearMarkers">
          <!-- Year markers will be inserted via JavaScript -->
        </div>
      </div>
    </div>

    <!-- Main Events Timeline -->
    <div class="timeline-container">
      <h3 class="timeline-section-title">Events</h3>
      <div class="timeline-line"></div>

      <!-- √çcones de setas para navega√ß√£o -->
      <button class="carousel-arrow left" id="carouselPrev">
        <svg class="arrow-icon" viewBox="0 0 24 24" fill="none">
          <path
            d="M15 18L9 12L15 6"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          />
        </svg>
      </button>

      <button class="carousel-arrow right" id="carouselNext">
        <svg class="arrow-icon" viewBox="0 0 24 24" fill="none">
          <path
            d="M9 18L15 12L9 6"
            stroke="currentColor"
            stroke-width="2"
            stroke-linecap="round"
            stroke-linejoin="round"
          />
        </svg>
      </button>

      <div class="timeline" id="timeline">
        <!-- Events will be inserted via JavaScript -->
      </div>
    </div>

    <div class="navigation">
      <button class="nav-btn" id="prevBtn">
        <span>&lArr; Previous Event</span>
      </button>
      <button class="nav-btn" id="nextBtn">
        <span>Next Event &rArr;</span>
      </button>
    </div>

    <footer>
      <div class="footer-disclaimer">
        <p>
          This timeline is an unofficial fan project. All rights to the Horizon
          series, including characters, stories, locations, and worlds, are
          property of Guerrilla Games and Sony Interactive Entertainment.
        </p>
        <br />
        <p>
          This project is not endorsed, sponsored, or affiliated with Guerrilla
          Games or Sony. All information was compiled and adapted from the
          <a
            href="https://horizon.fandom.com/wiki/Timeline"
            target="_blank"
            rel="noopener noreferrer"
          >
            Horizon Wiki Timeline </a
          >, developed by the fan community, and rewritten for this
          presentation.
        </p>
        <br />
        <p>
          This non-commercial site is made by fans, for fans. No information
          presented here is for sale, rent, or trade. ¬© 2025 Fan Project. All
          original presentation rights reserved.
        </p>
      </div>
    </footer>

    <!-- popup -->
    <div id="welcomePopup" class="popup-overlay">
      <div class="popup-container">
        <div class="popup-header">
          <h2>Welcome to: A Timeline For Horizon!</h2>
          <button class="popup-close" id="closePopup">&times;</button>
        </div>

        <div class="popup-content">
          <p>
            <strong style="color: red">Made by fan, for fans ‚ù§Ô∏è</strong> ‚Üí This
            is an
            <strong style="color: rgb(248, 3, 248)"
              >unofficial interactive timeline</strong
            >, showcasing the main events of the Horizon game series.
          </p>

          <div class="popup-features">
            <div class="feature-item">
              <span class="feature-icon">üéÆ</span>
              <span>Explore events in chronological order</span>
            </div>
            <div class="feature-item">
              <span class="feature-icon">üìÖ</span>
              <span>Navigate through years using the top timeline</span>
            </div>
            <div class="feature-item">
              <span class="feature-icon">üîç</span>
              <span>Click on any card to view details</span>
            </div>
            <div class="feature-item">
              <span class="feature-icon">‚ö°</span>
              <span>Use the buttons for quick navigation</span>
            </div>
          </div>

          <div class="popup-disclaimer">
            <p>
              <strong>Important:</strong> This is an independent fan project and
              is not affiliated with Guerrilla Games or Sony. All content is
              based on public community information.
            </p>
          </div>
        </div>

        <div class="popup-footer">
          <button class="popup-button" id="acknowledgeButton">
            I understand. I am aware that this is NOT an Official Website. ‚úÖ
          </button>
        </div>
      </div>
    </div>

    <script>
      // Timeline data
      const timelineEvents = [
        {
          year: '2009',
          yearTitleCard: '2009',
          month: 'Unknown Month',
          day: 'Unknown Day',
          title: "Harriet Choi's birth",
          description:
            'Born around 2009, she later in her life became a bioterrorist and member of the Naysay Doom, a death cult that existed in the 21st Century. This group engineered the "Doom Plague" viral cocktail, which was later released in  New York, London, Moscow, Tokyo, and Shanghai in the year 2039, killing millions of people. Following the attack in 2039, many countries outlawed burgeoning research on genetic testing.',
        },
        {
          year: '2013',
          yearTitleCard: '2013',
          month: 'December',
          day: '24th',
          title: "Ted Faro's birth",
          description:
            "The future reponsible for humanity's doom, Theodor 'Ted' Faro, was born on this date.",
        },
        {
          year: '2017',
          yearTitleCard: '2017',
          month: 'Unknown Month',
          day: 'Unknown Day',
          title: 'Law changes in the US',
          description:
            "The United States Interior Department decides to remove the grizzly bear species from it's endangered species list.",
        },
        {
          year: '2020',
          yearTitleCard: '2020',
          month: 'March',
          day: '12',
          title: 'Franchise Reboot',
          description:
            'Series restart with new graphics engine, maintaining the essence of the original story.',
        },
        {
          year: '2023',
          yearTitleCard: '2023',
          month: 'October',
          day: '27',
          title: 'Multiverse Expansion',
          description:
            'Largest expansion ever released, introducing the concept of multiverse and alternate realities.',
        },
      ];

      // Global variables
      let currentIndex = 0;
      let currentPosition = 0;
      const eventWidth = 330;
      let maxIndex = 0;
      let maxPosition = 0;

      // Wait for DOM to be fully loaded
      document.addEventListener('DOMContentLoaded', function () {
        console.log('DOM fully loaded - initializing application');
        initializeApplication();
      });

      // Historical periods data
      const historicalPeriods = [
        {
          id: 'old-world',
          name: 'Old World (2009 - 2068)',
          startYear: 2009,
          endYear: 2068,
          color: '#ffd700',
          description:
            'The era of advanced technology and the creation of the Faro Plague',
        },
        {
          id: 'new-world',
          name: 'New World',
          startYear: 2326,
          endYear: 3020,
          color: '#ffa500',
          description: 'The rebirth of life on Earth through Project Zero Dawn',
        },
        {
          id: 'zero-dawn',
          name: 'Horizon Zero Dawn',
          startYear: 3040,
          endYear: 3040,
          color: '#32cd32',
          description:
            "Aloy's journey to uncover the truth about the Old World",
        },
        {
          id: 'frozen-wilds',
          name: 'Frozen Wilds',
          startYear: 3040,
          endYear: 3040,
          color: '#32cd32',
          description: "Aloy's journey to Banuk territory",
        },
        {
          id: 'forbidden-west',
          name: 'Horizon Forbidden West',
          startYear: 3040,
          endYear: 3041,
          color: '#1e90ff',
          description:
            "Aloy's quest to restore GAIA and save the world from extinction",
        },
        {
          id: 'burning-shores',
          name: 'Burning Shores',
          startYear: 3041,
          endYear: 3041,
          color: '#32cd32',
          description: "Aloy's journey to the Burning Shores",
        },
      ];

      function throttle(func, limit) {
        let inThrottle;
        return function () {
          const args = arguments;
          const context = this;
          if (!inThrottle) {
            func.apply(context, args);
            inThrottle = true;
            setTimeout(() => (inThrottle = false), limit);
          }
        };
      }

      // Use throttle para eventos de redimensionamento
      window.addEventListener(
        'resize',
        throttle(() => {
          if (currentIndex >= 0) {
            navigateToIndex(currentIndex);
          }
        }, 250)
      );

      // Initialize historical periods
      function initializeHistoricalPeriods() {
        const periodsTrack = document.getElementById('periodsTrack');
        if (!periodsTrack) return;

        // Get all unique years from timeline
        const allYears = [
          ...new Set(timelineEvents.map((event) => parseInt(event.year))),
        ].sort((a, b) => a - b);
        const minYear = Math.min(...allYears);
        const maxYear = Math.max(...allYears);
        const totalYears = maxYear - minYear;

        // Create period ranges and markers
        historicalPeriods.forEach((period) => {
          // Calculate position for period range
          const startPos = ((period.startYear - minYear) / totalYears) * 100;
          const endPos = ((period.endYear - minYear) / totalYears) * 100;
          const width = endPos - startPos;

          // Create period range
          const periodRange = document.createElement('div');
          periodRange.className = 'period-range';
          periodRange.style.left = `${startPos}%`;
          periodRange.style.width = `${width}%`;
          periodRange.title = `${period.name}: ${period.startYear}-${period.endYear}\n${period.description}`;
          periodsTrack.appendChild(periodRange);

          // Create period marker (start)
          const periodMarker = document.createElement('div');
          periodMarker.className = 'period-marker';
          periodMarker.style.left = `${startPos}%`;
          periodMarker.innerHTML = `
            <div class="period-dot"></div>
            <div class="period-label">${period.name}</div>
        `;
          periodMarker.title = `${period.name}: ${period.startYear}-${period.endYear}\n${period.description}`;

          periodMarker.addEventListener('click', () => {
            // Find first event in this period
            const firstEventInPeriod = timelineEvents.find(
              (event) =>
                parseInt(event.year) >= period.startYear &&
                parseInt(event.year) <= period.endYear
            );
            if (firstEventInPeriod) {
              playSound('period', 0.4);
              navigateToYear(firstEventInPeriod.year);
            }
          });

          periodsTrack.appendChild(periodMarker);
        });
      }

      // Update active historical period based on current year
      function updateActivePeriod(currentYear) {
        const year = parseInt(currentYear);

        // Remove active class from all periods
        document
          .querySelectorAll('.period-marker, .period-range')
          .forEach((el) => {
            el.classList.remove('active', 'active-period');
          });

        // Find current period
        const currentPeriod = historicalPeriods.find(
          (period) => year >= period.startYear && year <= period.endYear
        );

        if (currentPeriod) {
          // Add active class to current period
          const periodMarkers = document.querySelectorAll('.period-marker');
          const periodRanges = document.querySelectorAll('.period-range');

          periodMarkers.forEach((marker) => {
            if (
              marker.querySelector('.period-label').textContent ===
              currentPeriod.name
            ) {
              marker.classList.add('active');
            }
          });

          periodRanges.forEach((range) => {
            if (range.title.includes(currentPeriod.name)) {
              range.classList.add('active-period');
            }
          });
        }
      }

      function setupKeyboardNavigation() {
        document.addEventListener('keydown', function (event) {
          // Verifica se as teclas s√£o seta esquerda ou direita
          if (event.key === 'ArrowLeft') {
            event.preventDefault();
            if (currentIndex > 0) {
              navigateToIndex(currentIndex - 1);
            }
          } else if (event.key === 'ArrowRight') {
            event.preventDefault();
            if (currentIndex < maxIndex) {
              navigateToIndex(currentIndex + 1);
            }
          }
        });
      }

      // Timeline initialization
      function initializeTimeline() {
        const timeline = document.getElementById('timeline');
        const yearMarkers = document.getElementById('yearMarkers');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');

        if (!timeline || !yearMarkers || !prevBtn || !nextBtn) {
          console.error('Required timeline elements not found');
          return;
        }

        // Create year markers
        const uniqueYears = [
          ...new Set(timelineEvents.map((event) => event.year)),
        ].sort();
        uniqueYears.forEach((year, index) => {
          const yearMarker = document.createElement('div');
          yearMarker.className = `year-marker ${index === 0 ? 'active' : ''}`;
          yearMarker.innerHTML = `
              <div class="year-dot"></div>
              <span class="year-label">${year}</span>
            `;
          yearMarker.addEventListener('click', () => navigateToYear(year));
          yearMarkers.appendChild(yearMarker);
        });

        // Create timeline content
        const eventsByYear = groupEventsByYear(timelineEvents);
        let totalElements = 0;

        Object.keys(eventsByYear).forEach((year) => {
          // Create year title
          const yearTitle = document.createElement('div');
          yearTitle.className = 'year-title';
          yearTitle.textContent = year;
          yearTitle.dataset.year = year;
          timeline.appendChild(yearTitle);
          totalElements++;

          // Add events for this year
          eventsByYear[year].forEach((event) => {
            const eventElement = createEventElement(event, year);
            eventElement.addEventListener('click', () => {
              const elementIndex = Array.from(timeline.children).indexOf(
                eventElement
              );
              playSound('select', 0.3);
              navigateToIndex(elementIndex);
            });
            timeline.appendChild(eventElement);
            totalElements++;
          });
        });

        // Setup navigation
        maxIndex = timeline.children.length - 1;
        maxPosition = maxIndex * eventWidth;

        // Event listeners for navigation buttons
        prevBtn.addEventListener('click', () => {
          if (currentIndex > 0) navigateToIndex(currentIndex - 1);
        });

        nextBtn.addEventListener('click', () => {
          if (currentIndex < maxIndex) navigateToIndex(currentIndex + 1);
        });

        // Initialize first state
        navigateToIndex(0);
        enhanceYearTitles();
      }

      // Inicializar setas do carrossel - CHAMAR DEPOIS que o timeline estiver pronto
      function initializeCarouselArrows() {
        const carouselPrev = document.getElementById('carouselPrev');
        const carouselNext = document.getElementById('carouselNext');

        console.log('Inicializando setas do carrossel:', {
          carouselPrev,
          carouselNext,
        });

        if (carouselPrev) {
          carouselPrev.addEventListener('click', () => {
            console.log('Seta anterior clicada, currentIndex:', currentIndex);
            if (currentIndex > 0) {
              navigateToIndex(currentIndex - 1);
            }
          });
        }

        if (carouselNext) {
          carouselNext.addEventListener('click', () => {
            console.log(
              'Seta pr√≥xima clicada, currentIndex:',
              currentIndex,
              'maxIndex:',
              maxIndex
            );
            if (currentIndex < maxIndex) {
              navigateToIndex(currentIndex + 1);
            }
          });
        }
      }

      // Atualizar estado das setas
      function updateCarouselArrows() {
        const carouselPrev = document.getElementById('carouselPrev');
        const carouselNext = document.getElementById('carouselNext');

        if (carouselPrev) {
          carouselPrev.disabled = currentIndex === 0;
        }
        if (carouselNext) {
          carouselNext.disabled = currentIndex >= maxIndex;
        }
      } // ========== FIM DO C√ìDIGO DAS SETAS ==========

      // ========== SISTEMA DE SONS COM WEB AUDIO API (SEM ARQUIVOS) ==========

      let soundEnabled = true;
      let audioContext = null;

      // Inicializar sistema de som
      function initializeSoundSystem() {
        // Verificar prefer√™ncia salva
        const savedSoundPreference = localStorage.getItem(
          'horizonTimelineSoundEnabled'
        );
        if (savedSoundPreference !== null) {
          soundEnabled = savedSoundPreference === 'true';
        }

        // Criar controles de som
        createSoundControls();

        // Inicializar Web Audio API
        initializeAudioContext();

        // Configurar event listeners para sons
        setupSoundEventListeners();

        console.log('Sistema de sons inicializado. Sons ativos:', soundEnabled);
      }

      // Inicializar contexto de √°udio
      function initializeAudioContext() {
        try {
          const AudioContext = window.AudioContext || window.webkitAudioContext;
          audioContext = new AudioContext();
          console.log('Contexto de √°udio criado com sucesso');
        } catch (error) {
          console.log('Web Audio API n√£o suportada:', error);
        }
      }

      // Criar sons sintetizados
      function createSound(frequency, duration, type = 'sine', volume = 0.3) {
        if (!soundEnabled || !audioContext) return;

        try {
          // Criar oscilador
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();

          // Configurar oscilador
          oscillator.type = type;
          oscillator.frequency.setValueAtTime(
            frequency,
            audioContext.currentTime
          );

          // Configurar volume (envelope)
          gainNode.gain.setValueAtTime(0, audioContext.currentTime);
          gainNode.gain.linearRampToValueAtTime(
            volume,
            audioContext.currentTime + 0.01
          );
          gainNode.gain.exponentialRampToValueAtTime(
            0.001,
            audioContext.currentTime + duration
          );

          // Conectar n√≥s
          oscillator.connect(gainNode);
          gainNode.connect(audioContext.destination);

          // Tocar som
          oscillator.start(audioContext.currentTime);
          oscillator.stop(audioContext.currentTime + duration);
        } catch (error) {
          console.log('Erro ao criar som:', error);
        }
      }

      class HarmonicThemeMusic {
        constructor() {
          this.audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
          this.isPlaying = false;
          this.currentStep = 0;
          this.mainVolume = 0.3;
        }

        // Criar oscilador suave para harmonia
        createHarmonicOscillator(
          freq,
          type,
          duration,
          volume,
          detune = 0,
          fadeIn = 0.1
        ) {
          const now = this.audioContext.currentTime;
          const osc = this.audioContext.createOscillator();
          const gain = this.audioContext.createGain();
          const filter = this.audioContext.createBiquadFilter();

          osc.type = type;
          osc.frequency.setValueAtTime(freq, now);
          osc.detune.setValueAtTime(detune, now);

          // Filtro suave para som mais org√¢nico
          filter.type = 'lowpass';
          filter.frequency.setValueAtTime(1800, now);
          filter.Q.setValueAtTime(1, now);

          // Envelope suave
          gain.gain.setValueAtTime(0, now);
          gain.gain.linearRampToValueAtTime(volume, now + fadeIn);
          gain.gain.exponentialRampToValueAtTime(0.001, now + duration);

          osc.connect(filter);
          filter.connect(gain);
          gain.connect(this.audioContext.destination);

          osc.start(now);
          osc.stop(now + duration);
        }

        // Pad harm√¥nico principal - base da m√∫sica
        playHarmonicPad() {
          if (this.currentStep % 16 === 0) {
            // Acorde Am (L√° menor) - melanc√≥lico e atmosf√©rico
            const amChord = [
              220.0, // A3
              261.63, // C4
              329.63, // E4
              440.0, // A4
            ];

            amChord.forEach((freq, index) => {
              setTimeout(() => {
                this.createHarmonicOscillator(
                  freq,
                  'sine',
                  4.0,
                  this.mainVolume * 0.4,
                  index * 2
                );
              }, index * 100);
            });
          }
        }

        // Melodia principal suave
        playMainMelody() {
          const melodyNotes = [
            { step: 0, freq: 440.0, duration: 1.5, vol: 0.6 }, // A4
            { step: 4, freq: 523.25, duration: 1.0, vol: 0.5 }, // C5
            { step: 8, freq: 493.88, duration: 1.0, vol: 0.5 }, // B4
            { step: 12, freq: 440.0, duration: 2.0, vol: 0.4 }, // A4
            { step: 16, freq: 392.0, duration: 1.5, vol: 0.5 }, // G4
            { step: 20, freq: 349.23, duration: 1.0, vol: 0.5 }, // F4
            { step: 24, freq: 329.63, duration: 1.0, vol: 0.6 }, // E4
            { step: 28, freq: 293.66, duration: 2.0, vol: 0.4 }, // D4
          ];

          const currentNote = melodyNotes.find(
            (note) => note.step === this.currentStep % 32
          );
          if (currentNote) {
            this.createHarmonicOscillator(
              currentNote.freq,
              'triangle',
              currentNote.duration,
              this.mainVolume * currentNote.vol,
              Math.random() * 4 - 2, // Detune sutil
              0.3 // Fade-in mais longo
            );
          }
        }

        // Contraponto mel√≥dico secund√°rio
        playCounterMelody() {
          const counterNotes = [
            { step: 8, freq: 659.25, duration: 2.0, vol: 0.3 }, // E5
            { step: 16, freq: 587.33, duration: 1.5, vol: 0.3 }, // D5
            { step: 24, freq: 523.25, duration: 2.0, vol: 0.3 }, // C5
          ];

          const currentNote = counterNotes.find(
            (note) => note.step === this.currentStep % 32
          );
          if (currentNote) {
            this.createHarmonicOscillator(
              currentNote.freq,
              'sine',
              currentNote.duration,
              this.mainVolume * currentNote.vol,
              5, // Detune fixo para destaque sutil
              0.4
            );
          }
        }

        // Baixo harm√¥nico
        playBassLine() {
          const bassNotes = [
            { step: 0, freq: 110.0, duration: 4.0 }, // A2
            { step: 16, freq: 98.0, duration: 4.0 }, // G2
          ];

          const currentNote = bassNotes.find(
            (note) => note.step === this.currentStep % 32
          );
          if (currentNote) {
            this.createHarmonicOscillator(
              currentNote.freq,
              'sine',
              currentNote.duration,
              this.mainVolume * 0.3,
              0,
              0.5
            );
          }
        }

        // Texturas atmosf√©ricas sutis
        playAtmosphericTextures() {
          if (this.currentStep % 8 === 0 && Math.random() < 0.4) {
            // Harm√¥nicos agudos sutis
            const harmonics = [880.0, 1318.51, 1760.0];
            const randomHarmonic =
              harmonics[Math.floor(Math.random() * harmonics.length)];

            this.createHarmonicOscillator(
              randomHarmonic,
              'sine',
              3.0,
              this.mainVolume * 0.15,
              10,
              0.8
            );
          }
        }

        // Progress√£o harm√¥nica variada
        playChordProgression() {
          const progressions = [
            { step: 0, chord: [220.0, 261.63, 329.63, 440.0] }, // Am
            { step: 8, chord: [196.0, 246.94, 293.66, 392.0] }, // G
            { step: 16, chord: [174.61, 220.0, 261.63, 349.23] }, // F
            { step: 24, chord: [164.81, 196.0, 246.94, 329.63] }, // Em
          ];

          const currentProgression = progressions.find(
            (prog) => prog.step === this.currentStep % 32
          );
          if (currentProgression) {
            currentProgression.chord.forEach((freq, index) => {
              setTimeout(() => {
                this.createHarmonicOscillator(
                  freq,
                  'sine',
                  8.0,
                  this.mainVolume * 0.25,
                  index * 3,
                  0.6
                );
              }, index * 150);
            });
          }
        }

        // Loop principal da m√∫sica harm√¥nica
        playStep() {
          if (!this.isPlaying) return;

          // Executar camadas harm√¥nicas
          this.playHarmonicPad();
          this.playMainMelody();
          this.playCounterMelody();
          this.playBassLine();
          this.playChordProgression();
          this.playAtmosphericTextures();

          this.currentStep++;

          // Timing mais lento para m√∫sica atmosf√©rica (500ms por step)
          setTimeout(() => this.playStep(), 500);
        }

        // Iniciar m√∫sica
        start() {
          if (this.isPlaying) return;

          this.audioContext.resume();
          this.isPlaying = true;
          this.currentStep = 0;
          this.playStep();

          console.log('üéµ M√∫sica Harm√¥nica Iniciada');
        }

        // Parar m√∫sica
        stop() {
          this.isPlaying = false;
          console.log('üéµ M√∫sica Harm√¥nica Parada');
        }

        // Ajustar volume
        setVolume(level) {
          this.mainVolume = Math.max(0, Math.min(1, level));
        }

        // Alternar play/pause
        toggle() {
          if (this.isPlaying) {
            this.stop();
          } else {
            this.start();
          }
          return this.isPlaying;
        }
      }

      // Inst√¢ncia global da m√∫sica harm√¥nica
      const harmonicMusic = new HarmonicThemeMusic();

      // Controles autom√°ticos para o site
      function initHarmonicMusicControls() {
        if (!document.getElementById('harmonicMusicToggle')) {
          const toggleBtn = document.createElement('button');
          toggleBtn.id = 'harmonicMusicToggle';
          toggleBtn.innerHTML = 'üéµ Play Music';
          toggleBtn.style.position = 'fixed';
          toggleBtn.style.bottom = '20px';
          toggleBtn.style.right = '20px';
          toggleBtn.style.zIndex = '1000';
          toggleBtn.style.padding = '10px 15px';
          toggleBtn.style.background =
            'linear-gradient(45deg, #2a2a2a, #4a4a4a)';
          toggleBtn.style.color = 'white';
          toggleBtn.style.border = '1px solid #666';
          toggleBtn.style.borderRadius = '8px';
          toggleBtn.style.cursor = 'pointer';
          toggleBtn.style.fontFamily = 'Arial, sans-serif';
          toggleBtn.style.fontSize = '14px';
          toggleBtn.style.transition = 'all 0.3s ease';

          toggleBtn.addEventListener('mouseenter', () => {
            toggleBtn.style.transform = 'scale(1.05)';
            toggleBtn.style.background =
              'linear-gradient(45deg, #3a3a3a, #5a5a5a)';
          });

          toggleBtn.addEventListener('mouseleave', () => {
            toggleBtn.style.transform = 'scale(1)';
            toggleBtn.style.background =
              'linear-gradient(45deg, #2a2a2a, #4a4a4a)';
          });

          toggleBtn.addEventListener('click', () => {
            const isPlaying = harmonicMusic.toggle();
            toggleBtn.innerHTML = isPlaying ? 'üéµ Stop Music' : 'üéµ Play Music';
            toggleBtn.style.background = isPlaying
              ? 'linear-gradient(45deg, #4a7a4a, #6a9a6a)'
              : 'linear-gradient(45deg, #2a2a2a, #4a4a4a)';
          });

          document.body.appendChild(toggleBtn);

          // Controle de volume sutil
          const volumeSlider = document.createElement('input');
          volumeSlider.type = 'range';
          volumeSlider.min = '0';
          volumeSlider.max = '100';
          volumeSlider.value = '30';
          volumeSlider.style.position = 'fixed';
          volumeSlider.style.bottom = '60px';
          volumeSlider.style.right = '20px';
          volumeSlider.style.width = '100px';
          volumeSlider.style.zIndex = '1000';

          volumeSlider.addEventListener('input', (e) => {
            harmonicMusic.setVolume(e.target.value / 100);
          });

          document.body.appendChild(volumeSlider);
        }
      }

      // Iniciar quando a p√°gina carregar
      document.addEventListener('DOMContentLoaded', initHarmonicMusicControls);

      // Sistema de inicializa√ß√£o com intera√ß√£o do usu√°rio
      function initHarmonicMusic() {
        document.addEventListener(
          'click',
          function startMusicOnClick() {
            harmonicMusic.start();

            // Atualizar bot√£o
            const toggleBtn = document.getElementById('harmonicMusicToggle');
            if (toggleBtn) {
              toggleBtn.innerHTML = 'üéµ Stop Music';
              toggleBtn.style.background =
                'linear-gradient(45deg, #4a7a4a, #6a9a6a)';
            }

            document.removeEventListener('click', startMusicOnClick);
          },
          { once: true }
        );
      }

      // Iniciar sistema de m√∫sica
      initHarmonicMusic();

      // Sons espec√≠ficos para diferentes intera√ß√µes
      function playSound(soundType, volume = 0.3) {
        if (!soundEnabled || !audioContext) return;

        // Garantir que o contexto esteja rodando (necess√°rio para alguns navegadores)
        if (audioContext.state === 'suspended') {
          audioContext.resume();
        }

        const sounds = {
          select: () => {
            // L√° (440Hz) - nota t√¥nica da m√∫sica, suave e integrada
            const now = audioContext.currentTime;
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();

            osc.type = 'sine';
            osc.frequency.setValueAtTime(440, now);
            osc.frequency.setValueAtTime(460, now + 0.02); // Pequeno bend sutil

            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(1200, now);

            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(volume * 0.5, now + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);

            osc.connect(filter);
            filter.connect(gain);
            gain.connect(audioContext.destination);

            osc.start(now);
            osc.stop(now + 0.3);
          },

          navigate: () => {
            // D√≥ (523.25Hz) - harmoniza com o acorde Am
            const now = audioContext.currentTime;
            const osc1 = audioContext.createOscillator();
            const osc2 = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();

            // Oscilador principal
            osc1.type = 'triangle';
            osc1.frequency.setValueAtTime(523.25, now);

            // Oscilador de oitava acima para riqueza harm√¥nica
            osc2.type = 'triangle';
            osc2.frequency.setValueAtTime(1046.5, now);

            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(1500, now);

            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(volume * 0.4, now + 0.1);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);

            osc1.connect(filter);
            osc2.connect(filter);
            filter.connect(gain);
            gain.connect(audioContext.destination);

            osc1.start(now);
            osc2.start(now);
            osc1.stop(now + 0.4);
            osc2.stop(now + 0.4);
          },

          period: () => {
            // Progress√£o Am (L√° menor) - mesma da m√∫sica
            const now = audioContext.currentTime;

            // Primeira nota - L√° (440Hz)
            const osc1 = audioContext.createOscillator();
            const gain1 = audioContext.createGain();
            osc1.type = 'sine';
            osc1.frequency.setValueAtTime(440, now);
            gain1.gain.setValueAtTime(0, now);
            gain1.gain.linearRampToValueAtTime(volume * 0.6, now + 0.1);
            gain1.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
            osc1.connect(gain1);
            gain1.connect(audioContext.destination);
            osc1.start(now);
            osc1.stop(now + 0.3);

            // Segunda nota - D√≥ (523.25Hz) com delay
            setTimeout(() => {
              const osc2 = audioContext.createOscillator();
              const gain2 = audioContext.createGain();
              osc2.type = 'sine';
              osc2.frequency.setValueAtTime(523.25, audioContext.currentTime);
              gain2.gain.setValueAtTime(0, audioContext.currentTime);
              gain2.gain.linearRampToValueAtTime(
                volume * 0.5,
                audioContext.currentTime + 0.1
              );
              gain2.gain.exponentialRampToValueAtTime(
                0.001,
                audioContext.currentTime + 0.3
              );
              osc2.connect(gain2);
              gain2.connect(audioContext.destination);
              osc2.start(audioContext.currentTime);
              osc2.stop(audioContext.currentTime + 0.3);
            }, 80);

            // Terceira nota - Mi (659.25Hz) com delay maior
            setTimeout(() => {
              const osc3 = audioContext.createOscillator();
              const gain3 = audioContext.createGain();
              const filter = audioContext.createBiquadFilter();

              osc3.type = 'sine';
              osc3.frequency.setValueAtTime(659.25, audioContext.currentTime);

              filter.type = 'lowpass';
              filter.frequency.setValueAtTime(1000, audioContext.currentTime);

              gain3.gain.setValueAtTime(0, audioContext.currentTime);
              gain3.gain.linearRampToValueAtTime(
                volume * 0.4,
                audioContext.currentTime + 0.1
              );
              gain3.gain.exponentialRampToValueAtTime(
                0.001,
                audioContext.currentTime + 0.4
              );

              osc3.connect(filter);
              filter.connect(gain3);
              gain3.connect(audioContext.destination);

              osc3.start(audioContext.currentTime);
              osc3.stop(audioContext.currentTime + 0.4);
            }, 160);
          },

          confirm: () => {
            // Acorde Am completo - resolu√ß√£o harm√¥nica
            const now = audioContext.currentTime;

            const frequencies = [
              440.0, // L√° - t√¥nica
              523.25, // D√≥ - terceira menor
              659.25, // Mi - quinta justa
              880.0, // L√° - oitava
            ];

            frequencies.forEach((freq, index) => {
              const osc = audioContext.createOscillator();
              const gain = audioContext.createGain();
              const filter = audioContext.createBiquadFilter();

              osc.type = 'sine';
              osc.frequency.setValueAtTime(freq, now);

              filter.type = 'lowpass';
              filter.frequency.setValueAtTime(2000, now);

              // Staggered start para efeito de arpejo suave
              gain.gain.setValueAtTime(0, now + index * 0.02);
              gain.gain.linearRampToValueAtTime(
                volume * (0.7 - index * 0.1),
                now + index * 0.02 + 0.05
              );
              gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);

              osc.connect(filter);
              filter.connect(gain);
              gain.connect(audioContext.destination);

              osc.start(now + index * 0.02);
              osc.stop(now + 0.5);
            });

            // Pulsa√ß√£o final para feedback t√°til
            setTimeout(() => {
              const pulseOsc = audioContext.createOscillator();
              const pulseGain = audioContext.createGain();

              pulseOsc.type = 'sine';
              pulseOsc.frequency.setValueAtTime(880, audioContext.currentTime);

              pulseGain.gain.setValueAtTime(0, audioContext.currentTime);
              pulseGain.gain.linearRampToValueAtTime(
                volume * 0.3,
                audioContext.currentTime + 0.05
              );
              pulseGain.gain.exponentialRampToValueAtTime(
                0.001,
                audioContext.currentTime + 0.2
              );

              pulseOsc.connect(pulseGain);
              pulseGain.connect(audioContext.destination);

              pulseOsc.start(audioContext.currentTime);
              pulseOsc.stop(audioContext.currentTime + 0.2);
            }, 200);
          },
        };

        // Fun√ß√£o auxiliar atualizada para manter compatibilidade
        function createSound(freq, duration, type, vol) {
          const now = audioContext.currentTime;
          const oscillator = audioContext.createOscillator();
          const gainNode = audioContext.createGain();
          const filter = audioContext.createBiquadFilter();

          oscillator.type = type;
          oscillator.frequency.setValueAtTime(freq, now);

          filter.type = 'lowpass';
          filter.frequency.setValueAtTime(1500, now);

          gainNode.gain.setValueAtTime(0, now);
          gainNode.gain.linearRampToValueAtTime(vol, now + 0.02);
          gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration);

          oscillator.connect(filter);
          filter.connect(gainNode);
          gainNode.connect(audioContext.destination);

          oscillator.start(now);
          oscillator.stop(now + duration);
        }

        if (sounds[soundType]) {
          sounds[soundType]();
        }
      }

      // Tocar som de teste
      function playTestSound() {
        if (!soundEnabled || !audioContext) return;

        // Sequ√™ncia de tons para teste
        const tones = [523.25, 659.25, 783.99]; // C5, E5, G5
        tones.forEach((freq, index) => {
          setTimeout(() => {
            createSound(freq, 0.2, 'sine', 0.2);
          }, index * 250);
        });
      }

      // Toggle de som
      function toggleSound() {
        soundEnabled = !soundEnabled;
        const soundToggle = document.getElementById('soundToggle');
        const soundIcon = document.getElementById('soundIcon');

        if (soundToggle && soundIcon) {
          if (soundEnabled) {
            soundToggle.classList.remove('muted');
            soundIcon.src =
              "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='white'%3E%3Cpath d='M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z'/%3E%3C/svg%3E";

            // Tocar som de confirma√ß√£o quando ativar
            setTimeout(() => playSound('confirm', 0.2), 100);
          } else {
            soundToggle.classList.add('muted');
            soundIcon.src =
              "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='white'%3E%3Cpath d='M3.63 3.63a.996.996 0 0 0 0 1.41L7.29 9H6c-1.1 0-2 .9-2 2v2c0 1.1.9 2 2 2h1.29l3.66 3.66c.39.39 1.02.39 1.41 0 .39-.39.39-1.02 0-1.41L5.05 5.05a.996.996 0 0 0-1.41 0l-1.01 1.01zm13.61 2.96c.49.25 1.02.48 1.59.66.18.06.31.23.31.42v2c0 .38-.31.71-.69.66-.95-.2-1.85-.52-2.69-.94l1.48-1.48zm-3.97-1.4c.33.14.65.29.96.46.17.09.31.26.31.46v2c0 .38-.31.71-.69.66-.32-.06-.64-.15-.94-.27l1.36-1.36zm-3.27 1.36L13 9.17V7h2c.55 0 1-.45 1-1s-.45-1-1-1h-2c-.55 0-1 .45-1 1v1.17l1.23 1.23zM7.34 10.84l-2-2H6c.55 0 1 .45 1 1v2c0 .55-.45 1-1 1h-.66l2 2H11v2.17l2 2V12h2l4 4h1.17l2 2a.996.996 0 1 0 1.41-1.41L4.41 2.86a.996.996 0 0 0-1.41 0c-.39.39-.39 1.03 0 1.42l2.34 2.34z'/%3E%3C/svg%3E";
          }
        }

        // Salvar prefer√™ncia
        localStorage.setItem(
          'horizonTimelineSoundEnabled',
          soundEnabled.toString()
        );
        console.log('Som ' + (soundEnabled ? 'ativado' : 'desativado'));
      }

      // Criar controles de som na interface
      function createSoundControls() {
        const soundControls = document.createElement('div');
        soundControls.className = 'sound-controls';
        soundControls.innerHTML = `
        <button id="soundToggle" class="sound-toggle ${
          soundEnabled ? '' : 'muted'
        }" title="${soundEnabled ? 'Desativar sons' : 'Ativar sons'}">
            <img id="soundIcon" class="sound-icon" src="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='white'%3E%3Cpath d='M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z'/%3E%3C/svg%3E" alt="Sound">
        </button>
    `;

        document.body.appendChild(soundControls);

        // Event listener para o toggle
        document
          .getElementById('soundToggle')
          .addEventListener('click', function () {
            // Se o contexto estiver suspenso, retomar primeiro
            if (audioContext && audioContext.state === 'suspended') {
              audioContext.resume().then(() => {
                toggleSound();
              });
            } else {
              toggleSound();
            }
          });

        // Adicionar evento de duplo clique para som de teste
        let clickCount = 0;
        let clickTimer;

        document
          .getElementById('soundToggle')
          .addEventListener('click', function () {
            clickCount++;
            if (clickCount === 1) {
              clickTimer = setTimeout(() => {
                clickCount = 0;
              }, 500);
            } else if (clickCount === 2) {
              clearTimeout(clickTimer);
              clickCount = 0;
              playTestSound();
            }
          });
      }

      // Configurar event listeners para sons
      function setupSoundEventListeners() {
        console.log('Configurando event listeners de som...');

        // Sons para navega√ß√£o principal
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const carouselPrev = document.getElementById('carouselPrev');
        const carouselNext = document.getElementById('carouselNext');

        if (prevBtn) {
          prevBtn.addEventListener('click', () => {
            console.log('Bot√£o anterior clicado - tocando som');
            playSound('navigate', 0.2);
          });
        }
        if (nextBtn) {
          nextBtn.addEventListener('click', () => {
            console.log('Bot√£o pr√≥ximo clicado - tocando som');
            playSound('navigate', 0.2);
          });
        }
        if (carouselPrev) {
          carouselPrev.addEventListener('click', () => {
            console.log('Seta anterior clicada - tocando som');
            playSound('navigate', 0.2);
          });
        }
        if (carouselNext) {
          carouselNext.addEventListener('click', () => {
            console.log('Seta pr√≥xima clicada - tocando som');
            playSound('navigate', 0.2);
          });
        }

        // Sons para sele√ß√£o de eventos
        document.addEventListener('click', (e) => {
          const timelineEvent = e.target.closest('.timeline-event');
          if (timelineEvent && !timelineEvent.classList.contains('active')) {
            console.log('Evento de timeline clicado - tocando som');
            playSound('select', 0.3);
          }
        });

        // Sons para per√≠odos hist√≥ricos
        document.addEventListener('click', (e) => {
          if (e.target.closest('.period-marker')) {
            console.log('Per√≠odo hist√≥rico clicado - tocando som');
            playSound('period', 0.4);
          }
        });

        // Sons para anos
        document.addEventListener('click', (e) => {
          if (e.target.closest('.year-marker')) {
            console.log('Ano clicado - tocando som');
            playSound('select', 0.25);
          }
        });

        // Sons para popup
        const acknowledgeBtn = document.getElementById('acknowledgeButton');
        if (acknowledgeBtn) {
          acknowledgeBtn.addEventListener('click', () => {
            playSound('confirm', 0.3);
          });
        }

        // Ativar √°udio no primeiro clique do usu√°rio (para destravar autoplay)
        const activateAudio = () => {
          if (audioContext && audioContext.state === 'suspended') {
            audioContext.resume().then(() => {
              console.log('√Åudio ativado pelo usu√°rio');
              // Remover event listeners ap√≥s ativa√ß√£o
              document.removeEventListener('click', activateAudio);
              document.removeEventListener('touchstart', activateAudio);
            });
          }
        };

        document.addEventListener('click', activateAudio);
        document.addEventListener('touchstart', activateAudio);

        console.log('Event listeners de som configurados');
      }

      // Adicione esta fun√ß√£o ao seu c√≥digo de sons
      const cardClickSound = () => {
        // Som similar ao "navigate" mas com identidade pr√≥pria para cards
        const now = audioContext.currentTime;

        // Camada principal - D√≥ (523.25Hz) para harmonia com a m√∫sica
        const mainOsc = audioContext.createOscillator();
        const mainGain = audioContext.createGain();
        const mainFilter = audioContext.createBiquadFilter();

        mainOsc.type = 'triangle';
        mainOsc.frequency.setValueAtTime(523.25, now);
        mainOsc.frequency.linearRampToValueAtTime(587.33, now + 0.15); // Transi√ß√£o suave para R√©

        mainFilter.type = 'lowpass';
        mainFilter.frequency.setValueAtTime(1200, now);

        mainGain.gain.setValueAtTime(0, now);
        mainGain.gain.linearRampToValueAtTime(volume * 0.5, now + 0.08);
        mainGain.gain.exponentialRampToValueAtTime(0.001, now + 0.35);

        // Camada harm√¥nica - oitava acima para riqueza
        const harmonicOsc = audioContext.createOscillator();
        const harmonicGain = audioContext.createGain();

        harmonicOsc.type = 'sine';
        harmonicOsc.frequency.setValueAtTime(1046.5, now); // D√≥ uma oitava acima

        harmonicGain.gain.setValueAtTime(0, now);
        harmonicGain.gain.linearRampToValueAtTime(volume * 0.2, now + 0.05);
        harmonicGain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);

        // Camada de "impacto" sutil
        const impactOsc = audioContext.createOscillator();
        const impactGain = audioContext.createGain();
        const impactFilter = audioContext.createBiquadFilter();

        impactOsc.type = 'sine';
        impactOsc.frequency.setValueAtTime(392.0, now); // Sol mais grave
        impactOsc.frequency.exponentialRampToValueAtTime(523.25, now + 0.1);

        impactFilter.type = 'highpass';
        impactFilter.frequency.setValueAtTime(200, now);

        impactGain.gain.setValueAtTime(0, now);
        impactGain.gain.linearRampToValueAtTime(volume * 0.3, now + 0.02);
        impactGain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);

        // Conectar tudo
        mainOsc.connect(mainFilter);
        mainFilter.connect(mainGain);
        mainGain.connect(audioContext.destination);

        harmonicOsc.connect(harmonicGain);
        harmonicGain.connect(audioContext.destination);

        impactOsc.connect(impactFilter);
        impactFilter.connect(impactGain);
        impactGain.connect(audioContext.destination);

        // Iniciar os osciladores
        mainOsc.start(now);
        harmonicOsc.start(now);
        impactOsc.start(now);

        // Parar os osciladores
        mainOsc.stop(now + 0.35);
        harmonicOsc.stop(now + 0.25);
        impactOsc.stop(now + 0.15);
      };

      // Adicione ao objeto sounds para manter organiza√ß√£o
      sounds.cardClick = cardClickSound;

      // Fun√ß√£o para adicionar o evento de clique aos cards
      function initCardSounds() {
        // Seletor para todos os cards - ajuste conforme seu HTML
        const cards = document.querySelectorAll(
          '.card, [class*="card"], [data-card]'
        );

        cards.forEach((card) => {
          // Remover event listener anterior para evitar duplica√ß√£o
          card.removeEventListener('click', handleCardClick);
          card.addEventListener('click', handleCardClick);
        });

        console.log(`üéµ Sons de card aplicados a ${cards.length} elementos`);
      }

      // Handler para o clique no card
      function handleCardClick(event) {
        // Tocar o som do card
        if (sounds.cardClick) {
          sounds.cardClick();
        }

        // Opcional: evitar propaga√ß√£o se necess√°rio
        // event.stopPropagation();
      }

      // Inicializar automaticamente quando a p√°gina carregar
      document.addEventListener('DOMContentLoaded', function () {
        // Inicializar imediatamente
        initCardSounds();

        // Re-inicializar a cada 2 segundos para capturar cards carregados dinamicamente
        setTimeout(initCardSounds, 2000);

        // Observar mudan√ßas no DOM para cards carregados dinamicamente
        const observer = new MutationObserver(function (mutations) {
          let shouldReinit = false;
          mutations.forEach(function (mutation) {
            if (mutation.addedNodes.length) {
              shouldReinit = true;
            }
          });
          if (shouldReinit) {
            setTimeout(initCardSounds, 100);
          }
        });

        observer.observe(document.body, {
          childList: true,
          subtree: true,
        });
      });

      // Tamb√©m pode ser chamada manualmente se voc√™ adicionar cards dinamicamente
      window.reinitCardSounds = initCardSounds;

      // ========== FIM DO SISTEMA DE SONS ==========

      function initializeApplication() {
        // Inicializa o timeline b√°sico
        initializeTimeline();

        // Inicializa per√≠odos hist√≥ricos
        initializeHistoricalPeriods();

        // navega√ß√£o por teclado
        setupKeyboardNavigation();

        // Inicializa as setas do carrossel - DEPOIS do timeline estar pronto
        initializeCarouselArrows();

        // Inicializa sistema de sons
        initializeSoundSystem();

        // Por √∫ltimo o popup
        initializePopup();

        // Apenas para desenvolvimento
        // if (
        //   window.location.hostname === 'localhost' ||
        //   window.location.hostname === '127.0.0.1'
        // ) {
        //   addDebugButtons();
        // }
      }

      // Helper functions for timeline
      function groupEventsByYear(events) {
        return events.reduce((groups, event) => {
          const year = event.year;
          if (!groups[year]) groups[year] = [];
          groups[year].push(event);
          return groups;
        }, {});
      }

      function createEventElement(event, year) {
        const eventElement = document.createElement('div');
        eventElement.className = 'timeline-event';
        eventElement.dataset.year = year;
        eventElement.onclick = () => {
          if (sounds && sounds.cardClick) {
            sounds.cardClick();
          }
        };

        eventElement.innerHTML = `
    <div class="event-marker"></div>
    <div class="event-content">
      <div class="event-header">
        <div class="event-date">
          <h3 class="event-title">${event.title}</h3>
          ${
            event.yearTitleCard
              ? `<span class="event-month">${event.yearTitleCard}</span>`
              : ''
          }
          ${
            event.month ? `<span class="event-month">${event.month}</span>` : ''
          }
          ${event.day ? `<span class="event-day">${event.day}</span>` : ''}
        </div>
      </div>
      <p class="event-description">${event.description}</p>
    </div>
  `;
        return eventElement;
      }

      function navigateToIndex(newIndex) {
        newIndex = Math.max(0, Math.min(newIndex, maxIndex));
        currentIndex = newIndex;

        const timeline = document.getElementById('timeline');
        const container = document.querySelector('.timeline-container');

        if (!timeline || !container) return;

        const containerWidth = container.offsetWidth;
        const timelineWidth = timeline.scrollWidth;

        // Calcula a posi√ß√£o para centralizar o elemento ativo
        const activeElement = timeline.children[currentIndex];
        if (!activeElement) return;

        // Posi√ß√£o do elemento ativo no timeline
        const activeElementPosition = currentIndex * eventWidth;

        // Centraliza o elemento ativo no container
        // Metade do container menos metade da largura do elemento
        currentPosition =
          activeElementPosition - containerWidth / 2 + eventWidth / 2;

        // Limita a posi√ß√£o para n√£o ultrapassar os limites
        const minPosition = 0;
        const maxPosition = Math.max(0, timelineWidth - containerWidth);

        currentPosition = Math.max(
          minPosition,
          Math.min(currentPosition, maxPosition)
        );

        // Aplica a transforma√ß√£o
        timeline.style.transform = `translateX(-${currentPosition}px)`;

        playSound('navigate', 0.2);
        updateActiveElement();
        updateButtons();
        updateYearMarkerFromCurrentIndex();
      }

      function navigateToYear(targetYear) {
        const yearTitle = document.querySelector(
          `.year-title[data-year="${targetYear}"]`
        );
        if (yearTitle) {
          const elementIndex = Array.from(
            document.getElementById('timeline').children
          ).indexOf(yearTitle);
          navigateToIndex(elementIndex);
        }
        playSound('select', 0.25);
      }

      function updateActiveElement() {
        const timeline = document.getElementById('timeline');
        if (!timeline) return;

        const currentElement = timeline.children[currentIndex];
        if (!currentElement) return;

        // Remove active classes
        document
          .querySelectorAll('.timeline-event, .year-title')
          .forEach((el) => {
            el.classList.remove('active', 'active-year');
          });

        // Add appropriate active class
        if (currentElement.classList.contains('timeline-event')) {
          currentElement.classList.add('active');
          const year = currentElement.dataset.year;
          const yearTitle = document.querySelector(
            `.year-title[data-year="${year}"]`
          );
          if (yearTitle) yearTitle.classList.add('active-year');
        } else if (currentElement.classList.contains('year-title')) {
          currentElement.classList.add('active-year');
        }
      }

      function updateYearMarkerFromCurrentIndex() {
        const timeline = document.getElementById('timeline');
        if (!timeline) return;

        const currentElement = timeline.children[currentIndex];
        if (!currentElement) return;

        let year;
        if (currentElement.classList.contains('year-title')) {
          year = currentElement.dataset.year || currentElement.textContent;
        } else if (currentElement.classList.contains('timeline-event')) {
          year = currentElement.dataset.year;
        }

        if (year) updateYearMarker(year);
      }

      function updateYearMarker(year) {
        document.querySelectorAll('.year-marker').forEach((marker) => {
          const yearLabel = marker.querySelector('.year-label');
          marker.classList.toggle(
            'active',
            yearLabel && yearLabel.textContent === year
          );
        });

        // Update active historical period
        updateActivePeriod(year);
      }
      function updateButtons() {
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        if (prevBtn) prevBtn.disabled = currentIndex === 0;
        if (nextBtn) nextBtn.disabled = currentIndex >= maxIndex;

        // Atualizar tamb√©m as setas do carrossel
        updateCarouselArrows();
      }

      function enhanceYearTitles() {
        document.querySelectorAll('.year-title').forEach((title) => {
          const decoration = document.createElement('div');
          decoration.className = 'year-decoration';
          title.appendChild(decoration);
        });
      }

      // Popup functions
      // Popup functions - Modified to force button click
      function initializePopup() {
        const popup = document.getElementById('welcomePopup');
        const closeBtn = document.getElementById('closePopup');
        const acknowledgeBtn = document.getElementById('acknowledgeButton');

        console.log('=== POPUP DEBUG ===');
        console.log('Popup element:', popup);
        console.log('Close button:', closeBtn);
        console.log('Acknowledge button:', acknowledgeBtn);

        if (!popup) {
          console.error('‚ùå Popup element not found!');
          return;
        }

        // USE THE NEW FUNCTION instead of the old logic
        if (shouldShowPopup()) {
          console.log('‚úÖ Should show popup - scheduling display');
          setTimeout(showPopup, 1000);
        } else {
          console.log('‚ùå Should NOT show popup');
        }

        setupPopupEventListeners();
      }

      function setupPopupEventListeners() {
        const popup = document.getElementById('welcomePopup');
        const closeBtn = document.getElementById('closePopup');
        const acknowledgeBtn = document.getElementById('acknowledgeButton');

        // Close button event - NOW SHOWS ALERT INSTEAD OF CLOSING
        if (closeBtn) {
          closeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            showRequiredAlert();
          });
        }

        // Acknowledge button event - ONLY WAY TO CLOSE
        if (acknowledgeBtn) {
          acknowledgeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            closePopup();
          });
        }

        // Overlay click event - DISABLED (user must click button)
        if (popup) {
          popup.addEventListener('click', (e) => {
            if (e.target === popup) {
              showRequiredAlert();
            }
          });
        }

        // Escape key event - DISABLED (user must click button)
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape') {
            const popup = document.getElementById('welcomePopup');
            if (popup && popup.classList.contains('active')) {
              e.preventDefault();
              showRequiredAlert();
            }
          }
        });
      }

      function showRequiredAlert() {
        // Create a custom alert instead of browser alert for better UX
        showCustomAlert(
          'You must declare that you are aware in order to proceed!'
        );

        // Optional: Add visual feedback to the button
        const acknowledgeBtn = document.getElementById('acknowledgeButton');
        if (acknowledgeBtn) {
          acknowledgeBtn.style.animation = 'pulseAttention 0.5s ease-in-out';
          setTimeout(() => {
            acknowledgeBtn.style.animation = '';
          }, 500);
        }
      }

      // Custom alert function for better user experience
      function showCustomAlert(message) {
        // Remove existing custom alert if any
        const existingAlert = document.getElementById('customAlert');
        if (existingAlert) {
          existingAlert.remove();
        }

        const alertOverlay = document.createElement('div');
        alertOverlay.id = 'customAlert';
        alertOverlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10001;
        backdrop-filter: blur(5px);
        animation: fadeIn 0.3s ease-out;
    `;

        const alertBox = document.createElement('div');
        alertBox.style.cssText = `
        background: var(--popup-bg);
        border: 2px solid var(--color-primary);
        border-radius: 15px;
        padding: 2rem;
        max-width: 400px;
        width: 90%;
        text-align: center;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(15px);
        animation: slideUp 0.3s ease-out;
    `;

        const alertMessage = document.createElement('p');
        alertMessage.textContent = message;
        alertMessage.style.cssText = `
        color: var(--color-text-primary);
        font-size: 1.1rem;
        margin-bottom: 1.5rem;
        line-height: 1.5;
    `;

        const alertButton = document.createElement('button');
        alertButton.textContent = 'go back and read';
        alertButton.style.cssText = `
        background: linear-gradient(135deg, var(--color-primary), var(--color-secondary));
        color: white;
        border: none;
        padding: 0.8rem 2rem;
        border-radius: 50px;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 4px 15px rgba(255, 126, 95, 0.3);
    `;

        alertButton.addEventListener('click', () => {
          alertOverlay.remove();
        });

        alertButton.addEventListener('mouseenter', () => {
          alertButton.style.transform = 'translateY(-2px)';
          alertButton.style.boxShadow = '0 6px 20px rgba(255, 126, 95, 0.4)';
        });

        alertButton.addEventListener('mouseleave', () => {
          alertButton.style.transform = 'translateY(0)';
          alertButton.style.boxShadow = '0 4px 15px rgba(255, 126, 95, 0.3)';
        });

        alertBox.appendChild(alertMessage);
        alertBox.appendChild(alertButton);
        alertOverlay.appendChild(alertBox);
        document.body.appendChild(alertOverlay);

        // Auto-remove after 5 seconds if user doesn't click
        setTimeout(() => {
          if (document.getElementById('customAlert')) {
            alertOverlay.remove();
          }
        }, 5000);
      }

      function showPopup() {
        const popup = document.getElementById('welcomePopup');
        if (popup) {
          console.log('Showing popup');
          popup.classList.add('active');
          document.body.style.overflow = 'hidden';
        }
      }
      function closePopup() {
        const popup = document.getElementById('welcomePopup');
        if (popup) {
          console.log('Closing popup and setting acknowledgment');
          popup.classList.remove('active');
          document.body.style.overflow = '';
          localStorage.setItem('horizonTimelineWelcomeSeen', 'true');
          localStorage.setItem('popupLastSeen', Date.now().toString());
        }
      }

      function shouldShowPopup() {
        // Check URL parameter for forced show
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get('showPopup') === 'true') {
          console.log('üîó URL parameter forces popup show');
          return true;
        }

        // Check if we're in development
        const isDevelopment =
          window.location.hostname === 'localhost' ||
          window.location.hostname === '127.0.0.1' ||
          window.location.protocol === 'file:';

        console.log('üåê Development environment:', isDevelopment);

        // For development - ALWAYS SHOW
        if (isDevelopment) {
          console.log('üîß Development mode - showing popup');
          return true;
        }

        // Production: normal behavior
        const hasAcknowledged = localStorage.getItem(
          'horizonTimelineWelcomeSeen'
        );
        console.log('üìù localStorage value:', hasAcknowledged);
        return !hasAcknowledged;
      }

      // Debug functions
      function addDebugButtons() {
        const debugDiv = document.createElement('div');
        debugDiv.id = 'debugButtons';
        debugDiv.style.cssText = `
            position: fixed; 
            bottom: 10px; 
            right: 10px; 
            z-index: 10000; 
            display: flex; 
            flex-direction: column; 
            gap: 5px;
          `;

        debugDiv.innerHTML = `
            <button onclick="resetPopup()" style="background: #ff4444; color: white; border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; font-size: 12px; font-weight: bold;">Reset Popup</button>
            <button onclick="forceShowPopup()" style="background: #44ff44; color: black; border: none; padding: 8px 12px; border-radius: 5px; cursor: pointer; font-size: 12px; font-weight: bold;">Show Popup</button>
          `;

        document.body.appendChild(debugDiv);
      }

      function resetPopup() {
        localStorage.removeItem('horizonTimelineWelcomeSeen');
        setTimeout(showPopup, 100);
      }

      function forceShowPopup() {
        showPopup();
      }

      // Make debug functions globally available
      window.resetPopup = resetPopup;
      window.forceShowPopup = forceShowPopup;

      function initializeApplication() {
        // Inicializa o timeline b√°sico
        initializeTimeline();

        // Inicializa per√≠odos hist√≥ricos
        initializeHistoricalPeriods();

        // navega√ß√£o por teclado
        setupKeyboardNavigation();

        // Inicializa as setas do carrossel - DEPOIS do timeline estar pronto
        initializeCarouselArrows();

        // INICIALIZA SISTEMA DE SONS
        initializeSoundSystem();

        // Por √∫ltimo o popup
        initializePopup();

        // Apenas para desenvolvimento
        // if (
        //   window.location.hostname === 'localhost' ||
        //   window.location.hostname === '127.0.0.1'
        // ) {
        //   addDebugButtons();
        // }
      }
    </script>
  </body>
</html>
